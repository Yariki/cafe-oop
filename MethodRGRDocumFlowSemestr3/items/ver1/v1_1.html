<html>
<head>
    <title>Об’єктно-орієнтоване програмування</title>
    <link rel="stylesheet" type="text/css" href="../../source/style.css">
</head>
<body background="../../source/background.jpg";>
<h1 align=center>Об’єктно-орієнтоване програмування</h1>
<table border="0" class="menu1" >
			<tr>
				<td><a href="../ver1/v1_1.html"><img border="0" src="../../source/v1.png"></a></td>
                <td><a href="../ver2/v2_1.html"><img border="0" src="../../source/v2.png"></a></td>
                <td><a href="../ver3/v3_1.html"><img border="0" src="../../source/v3.png"></a></td>
                <td><a href="../ver4/v4_1.html"><img border="0" src="../../source/v4.png"></a></td>
                <td><a href="../ver5/v5_1.html"><img border="0" src="../../source/v5.png"></a></td>
                <td><a href="../ver6/v6_1.html"><img border="0" src="../../source/v6.png"></a></td>
                <td><a href="../ver7/v7_1.html"><img border="0" src="../../source/v7.png"></a></td>
                <td><a href="../ver8/v8_1.html"><img border="0" src="../../source/v8.png"></a></td>
			</tr>
</table>
<table border="0" class="menu2">
			<tr>
				<td><a href="v1_1.html"><img border="0" src="../../source/m1.png"></a></td>
			</tr>
			<tr>
				<td><a href="v1_2.html"><img border="0" src="../../source/m2.png"></a></td>
			</tr>
            <tr>
				<td><a href="v1_3.html"><img border="0" src="../../source/m3.png"></a></td>
			</tr>
			<tr>
				<td><a href="v1_4.html"><img border="0" src="../../source/m4.png"></a></td>
			</tr>
            <tr>
				<td><a href="v1_5.html"><img border="0" src="../../source/m5.png"></a></td>
			</tr>
            <tr>
				<td><a href="v1_6.html"><img border="0" src="../../source/m6.png"></a></td>
			</tr>
            <tr>
				<td>&nbsp</td>
			</tr>
            <tr>
				<td>&nbsp</td>
			</tr>
            <tr>
				<td>&nbsp</td>
			</tr>
            <tr>
				<td><a href="../rating.html"><img border="0" src="../../source/m7.png"></a></td>
			</tr>
            <tr>
				<td><a href="../requir.html"><img border="0" src="../../source/m8.png"></a></td>
			</tr>
</table>
<a href="../../main.html"><img border="0" class="home" src="../../source/home.png"></a>
<div class="text">
<h2 id="up">Версія 1. Інкапсуляція. Інтерфейси класів. Діаграми прецедентів і класів.</h2>
<h3><u>Мета:</u></h3>
<ul>
<li>здійснити об’єктно-орієнтований аналіз та об’єктно-орієнтоване проектування предметного середовища засобами UML (Unified Modeling Language)</li>
</ul>
<h3><u>Теоретичні відомості</u></h3>

<ul>
<li><a href="#ooa">Об'єктно-орієнтований аналіз</a></li>
<li><a href="#dia">Діаграма варіантів використання</a></li>
</ul>

<h3 id="ooa">Об'єктно-орієнтований аналіз</h3>

<ul>
<li><a href="#et">Етапи об’єктно-орієнтованого проектування та моделювання</a></li>
<li><a href="#idcl">Ідентифікація класів</a></li>
<li><a href="#idat">Ідентифікація атрибутів</a></li>
<li><a href="#idop">Ідентифікація операцій (методів)</a></li>
<li><a href="#rel">Відношення між класами</a></li>
</ul>

<h4 id="et">Етапи об’єктно-орієнтованого проектування та моделювання</h4>
Процес розробки візуальних моделей в нотації мови UML 2.0 представляється у формі послідовної деталізації модельних представлень від концептуальної моделі до логічної, а потім й до фізичної моделі програмної системи, що розглядається. Можна виділити такі етапи ООA та OOD:
<ol>
<li>Визначення типів взаємодій між користувачем та системою. Побудова діаграми прецедентів (варіантів використання).</li>
<li>Ідентифікація класів. Побудова діаграм класів і об’єктів.</li>
<li>Ідентифікація атрибутів. Доповнення діаграми класів атрибутами. </li>
<li>Ідентифікація операцій (методів). Доповнення діаграми класів методами.</li>
<li>Визначення відношень між класами. Доповнення діаграми класів відношеннями між класами.</li>
<li>Визначення алгоритмів методів (функцій). Побудова діаграм діяльності, послідовностей, станів і переходів, кооперації.</li>
</ol>
<a href="#up"><sub>[up]</sub></a>

<h4 id="idcl">Ідентифікація класів</h4>
Клас(class) - елемент моделі, який описує множину об’єктів, що мають однакові специфікації характеристик, обмежень та семантики. Діаграма класів(class diagram) – діаграма, що призначена для представлення моделі статичної структури програмної системи в термінології класів об’єктно-орієнтованого програмування. 
<br>Для ідентифікації класів слід виконати такі дії:
<ol>
<li>Здійснити аналіз постановки задачі та визначити усі іменники, тобто побудувати словник даних.
<br>Аналіз опису предметного  середовища дозволяє визначити об'єкти і класи об'єктів, пов'язані з прикладною проблемою. Всі класи мають бути осмислені в даній прикладній області; класів, пов'язаних з комп'ютерною реалізацією, як наприклад список, стік і тому подібне на цьому етапі вводити не слід. 
<br>Почати слід з виділення можливих класів з опису постановки прикладного завдання (технічного завдання і іншої документації, наданої замовником). При виділенні можливих класів кожному іменнику з опису постановки завдання зазвичай зіставляється можливий клас. 
<li>Список можливих класів має бути проаналізований з метою виключення з нього непотрібних класів. Такими класами є: 
­<ul>
    <li><i>надлишкові класи</i>: якщо два або декілька класів виражають однакову інформацію, слід зберегти лише один з них; </li>
    <li><i>нерелевантні </i>(що не мають прямого відношення до проблеми) класи: для кожного імені можливого класу оцінюється, наскільки він необхідний в майбутній системі; нерелевантні класи виключаються; </li>
    <li><i>нечітко визначені </i>(з точки зору даної проблеми) класи;</li>
    <li><i>атрибути</i>: деяким іменникам більше відповідають не класи, а атрибути; такі іменники, як правило, описують властивості об'єктів (наприклад, ім'я, вік, вага, адреса і тому подібне); </li>
    <li><i>операції</i>: деяким іменникам більше відповідають не класи, а імена операцій (наприклад, телефонний виклик навряд чи означає який-небудь клас); </li>
    <li><i>ролі</i>: деякі іменники визначають імена ролей в об'єктній моделі (наприклад, власник, водій, начальник, службовець; всі ці імена пов'язані з ролями в різних залежностях об'єктів класу чоловік); </li>
    <li><i>реалізаційні конструкції</i>: іменам, більше пов'язаним з програмуванням і комп'ютерною апаратурою, не слід на даному етапі зіставляти класів, оскільки вони не відображають особливостей проектованої прикладної системи; приклади таких імен: підпрограма, процес, алгоритм, переривання і тому подібне.</li>
</ul></li></ol>
Після виключення імен всіх непотрібних (зайвих) можливих класів буде отриманий попередній список класів, складових проектовану систему.<br><br>
<a href="#up"><sub>[up]</sub></a>

<h4 id="idat">Ідентифікація атрибутів</h4>
Атрибут(attribute) класу служити для представлення окремої структурної характеристики чи властивості, які є загальними для всіх об’єктів даного класу. Атрибути зазвичай відповідають іменникам; наприклад колір автомобіля (властивість об'єкту), позиція курсору (достаток об'єкту). Атрибути, як правило, слабо впливають на структуру об'єктної моделі. 
<br>Для ідентифікації атрибутів слід виконати такі дії.
<ol>
<li>У постановці задачі знайти іменникові фрази. </li>
<li>Створити атрибути, що виражають властивості об’єктів класу, або визначають їх поточний стан. </li>
</ol>
При уточненні атрибутів керуються наступними критеріями: 
<ul>
­	<li><i>заміна атрибутів на об'єкти.</i> Якщо наявність деякої суті важливіша, ніж її значення, то це об'єкт, якщо важливіше значення, то це атрибут: наприклад, начальник - це об'єкт (неважливо, КТО саме начальник, головне, щоб хтось ним був), зарплата - це атрибут (її значення вельми істотно); місто - завжди об'єкт, хоча в деяких випадках може здатися, що це атрибут (наприклад, місто як частина адреси фірми); у тих випадках, коли потрібно, щоб місто було атрибутом, слід визначити залежність (скажімо, знаходиться) між класами фірма і місто; </li>
­	<li><i>кваліфікатори.</i> Якщо значення атрибуту залежить від конкретного контексту, його слід зробити кваліфікатором; </li>
­	<li><i>імена<.</i> Іменам зазвичай краще відповідають кваліфікатори, чим атрибути об'єктів; у всіх випадках, коли ім'я дозволяє зробити вибір з об'єктів деякої безлічі, його слід зробити кваліфікатором;</li>
­	<li><i>ідентифікатори.</i> Ідентифікатори об'єктів пов'язані з їх реалізацією. На ранніх стадіях проектування їх не слід розглядати як атрибути; </li>
­	<li><i>атрибути зв'язків.</i> Якщо деяку властивість характеризує не об'єкт сам по собі, а його зв'язок з іншим об'єктом (об'єктами), то це атрибут зв'язку, а не атрибут об'єкту; </li>
­	<li><i>внутрішні значення.</i> Атрибути, що визначають лише внутрішній достаток об'єкту, непомітний поза об'єктом, слід виключити з розгляду;</li>
­	<li><i>неістотні деталі.</i> Атрибути, що не впливають на виконання більшої частини операцій, рекомендується опустити. </li>
</ul>
<center>
<table border="0" >
			<tr>
				<td><img border="0" src="../../source/ver1/teor2.jpg"></td>
			</tr>
            <tr>
				<td><center><i>Рис 1. Фрагмент діаграми класів</i></center></td>
			</tr>
</table>
</center>
<a href="#up"><sub>[up]</sub></a>

<h4 id="idop">Ідентифікація операцій (методів)</h4>
Операція(operation) класу служить для представлення окремої характеристики поведінки, яка являється загальною для всіх об’єктів даного класу
<br>Виведення операцій здійснюють з постановки задачі через аналіз дієслів та їх фраз. Для цього слід виконати такі дії: 
<ol>
­	<li>Виділити явні та неявні дієслівні звороти.</li>
­	<li>Визначити доцільність використання дієслівних зворотів як імена можливих залежностей.</li>
­	<li>Виключити непотрібні чи неправильні залежності.</li>
­	<li>Уточнити семантику залежностей, що залишилися.</li>
­	<li>Розподілити операції по класах за такими критеріями:
­	<ul>
        <li>якщо операція виконується тільки над одним об’єктом, то вона визначається в класі, екземпляром котрого є цей об’єкт; </li>
        <li>якщо аргументами операції є об’єкти різних класів, то її слід включити до класу, до якого належить результат операції; </li>
        <li>якщо аргументами операції є об’єкти різних класів, причому змінюється значення тільки одного об’єкта, а значення інших об’єктів тільки читаються, то її слід включити до класу, до якого належить об’єкт, що змінюється; </li>
        <li>якщо класи разом з їх залежностями утворюють зірку з центром в одному з класів, то операцію, аргументами котрої є об’єкти цих класів, слід включити в центральний клас. </li>
    </ul></li>
</ol>
Потім слід прибрати непотрібні або неправильні залежності, використовуючи наступні критерії: 
­<ul>
­	<li>залежності між виключеними класами мають бути виключені, або переформульовані в термінах класів, що залишилися; </li>
­	<li>нерелевантні залежності і залежності, пов'язані з реалізацією, мають бути виключені; </li>
­	<li>дії: залежність повинна описувати структурні властивості прикладної області, а не малоістотні події; </li>
­	<li>тренарні залежності: велику частину залежностей між трьома або великим числом класів можна розкласти на декілька бінарних залежностей, використовуючи у разі потреби кваліфікатори; в деяких випадках таке розкладання здійснити не удається; наприклад, тренарна залежність "Професор читає курс в аудиторії 628" не може бути розкладена на бінарних без втрати інформації; </li>
­	<li>похідні залежності: потрібно виключати залежності, які можна виразити через інші залежності, оскільки вони надлишкові; при виключенні надлишкових (похідних) залежностей потрібно бути особливо обережним, оскільки не всі дублюючі одна іншу залежності між класами надлишкові; в деяких випадках інші залежності дозволяють встановити лише існування ще однієї похідної залежності, але не дозволяють встановити кратність цієї залежності; наприклад, фірма має тих, що багато служать і володіє багатьма комп'ютерами; кожному службовцеві надано для персонального використання декілька комп'ютерів, крім того, є комп'ютери спільного користування; кратність залежності предоставлен_для_использования не може бути виведена із залежностей служить і володіє; хоча похідні залежності і не додають нової інформації, вони часто бувають зручні; у цих випадках їх можна вказувати на діаграмі, помітивши косою межею.</li>
</ul>
Видаливши надлишкові залежності, потрібно уточнити семантику залежностей, що залишилися, таким чином: 
­­<ul>
­	<li>невірно названі залежності: їх слід перейменувати, щоб сенс їх став зрозумілий; </li>
­­	<li>імена ролей: потрібно додати імена ролей там, де це необхідно; ім'я ролі описує роль, яку грає відповідний клас в даній залежності з точки зору іншого класу, що бере участь в цій залежності; якщо ім'я ролі ясне з імені класу, його можна не вказувати; </li>
­	<li>кваліфікатори: додаючи кваліфікатори там, де це необхідно, ми вносимо елементи контексту, що дозволяє добитися однозначної ідентифікації об'єктів; кваліфікатори дозволяють також спростити деякі залежності, знизивши їх кратність; </li>
­	<li>кратність: необхідно додати позначення кратності залежностей; при цьому слід пам'ятати, що кратність залежностей може мінятися в процесі подальшого аналізу вимог до системи; </li>
­	<li>невраховані залежності мають бути виявлені і додані в модель. </li>
</ul>
<a href="#up"><sub>[up]</sub></a>

<h4 id="rel">Відношення між класами</h4>
Крім внутрішньої будови класів важливу роль при розробці моделей програмних систем мають різноманітні відношення між класами, які також можуть бути зображені на діаграмі класів. Сукупність допустимих типів відношень, які можуть бути представлені на діаграмі класів, фіксована в мові UML 2.0. Такими типами відношень чи взаємозв’язків, які можуть бути зображені на діаграмах класів, являються відношення асоціації та узагальнення, агрегації та композиції, залежності та реалізації.
<br>Кожне з цих відношень має власне графічне зображення та семантику, яка відображає характер та особливості відповідного взаємозв’язку між класами.
<center>
<table border="0" >
			<tr>
				<td><img border="0" src="../../source/ver1/teor3.jpg"></td>
			</tr>
            <tr>
				<td><center><i>Рис 2. Види зв’язків  у діаграмах класів</i></center></td>
			</tr>
</table>
</center>
<a href="#up"><sub>[up]</sub></a>

<ul>
<li><a href="#aso">Асоціація</a></li>
<li><a href="#ascl">Асоціація-клас</a></li>
<li><a href="#agr">Агрегація</a></li>
<li><a href="#comp">Композиція</a></li>
</ul>

<div id="aso"><b><i>Асоціація</i></b><br><br>

<i>Асоціація(association)</i> – довільне відношення чи взаємозв’язок між класами.
<br><br><i>Бінарна асоціація(binary association)</i> позначається неперервною лінією зі стрілкою чи без неї, можливо, з деякими додатковими символами, які характеризують спеціальні властивості асоціації. Лінії можуть бути зображені з використанням різноманітних стилів, включаючи ортогональні, похилі та криволінійні сегменти. Вибір окремої множини стилів ліній надаються користувачу.
<br><br>В якості додаткових спеціальних символів можуть використовуватись: ім’я асоціації, символ навігації, а також імена, видимість та кратність кінців асоціації. Хоча асоціації розглядались при вивченні діаграм варіантів використання, семантика цього типу відношень на діаграмі класів може бути використана в повному обсязі.
<br><br><i>Ім’я асоціації(association name)</i> являється необов’язковим елементом її позначення. Якщо воно задано, то записується з великої літері напівжирним шрифтом та розташовується поруч з символом асоціації, але не дуже близько до її кінця, щоб не переплутати з іменем цього кінця. Найбільш простий випадок такого відношення – бінарна асоціація, яка зв’язує тільки 2 класи. Окремим випадком бінарної асоціації являється рефлексивна асоціація, яка зв’язує клас з самим собою.
<br><br>При зображені асоціації особлива роль відводиться класам, що розташовані на кінцях лінії асоціації. Відповідний елемент в мові UML 2.0 має власну назву – кінець асоціації(association end), який графічно відповідає точці з’єднання лінії асоціації з прямокутником класу. При цьому по замовчуванню кінець асоціації представляє собою множину. Довільна асоціація може мати два чи більше кінців асоціації, кожний за яких, в свою чергу, може мати ім’я, видимість, кратність, символ наявності чи відсутності навігації, а також рядок властивості.
<ul>
    <li><i>кратність кінця асоціації</i> специфікує можливу кількість екземплярів відповідного класу, яка(кількість) може співвідноситись з одним екземпляром класу на іншому кінці цієї асоціації. Кратність кінців асоціації позначається в виді інтервалу цілих чисел, аналогічно кратності атрибутів класів, але без прямих дужок;</li>
    <li><i>символ наявності навігації(navigable)</i> зображується за допомогою простої стрілки в формі букви “V” на кінці асоціації. Наявність цієї стрілки вказує на те, що відповідний клас являється доступним для навігації зі стороні класів на інших кінцях асоціації;</li>
    <li><i>символ відсутності навігації(non navigable)</i> зображується за допомогою букви „Х” на лінії в кінці асоціації. Наявність цього символу вказує на те, що відповідний клас являється недоступним для навігації з боку класів на інших кінцях асоціації.</li>
</ul>
Зрозуміти призначення кінців асоціації допомагає знання особливостей генерації програмного коду на основі діаграми класів. Якщо для деякого кінця асоціації вказані його ім’я , видимість, кратність та навігація на протилежному кінці, то при генерації програмного коду для класу буде додано новий атрибут з іменем кінця асоціації, який розглядається, що має відповідну видимість та кратність. При цьому в якості типу нового атрибута буде використано ім’я класу на протилежному кінці асоціації, яка розглядається. Якщо ж для протилежного кінця асоціації не вказаний символ навігації, то при генерації програмного коду для класу ніякого нового атрибуту додано не буде.
<br><br>Окремим випадком відношення асоціації являється так зване <i>виключаюча асоціація(Xor-association)</i>. Семантика даної асоціації вказує на той факт, що з декількох потенціально-можливих варіантів даної асоціації в кожний момент часу може використовуватись тільки один її екземпляр. На діаграмі класів виключаюча асоціація зображується за допомогою пунктирної лінії, що з’єднує дві або більше асоціацій, поруч з якою записується обмеження в формі спеціального ключового слова {xor}.
</div>
<br><br><a href="#rel"><sub>[up]</sub></a>
<div id="ascl">
<br><br><b><i>Асоціація-клас</i></b><br><br>
<i>Асоціація-клас(association class)</i> – елемент моделі, який має властивості як асоціації, так і класу, та призначений для специфікації додаткових властивостей асоціації в формі атрибутів та, можливо, операцій класу.
<br><br>Асоціація-клас може розглядатися як асоціація, яка також має властивості класу, чи як клас, який також має властивості асоціації. Вона не тільки з’єднує множину класів, але й визначає множину характеристик, які належать самому відношення та не належать жодному з класів.
<br><br>Семантика асоціації-класу являється комбінацією семантики звичайної асоціації та класу, оскільки в мові UML 2.0 асоціація-клас являє прикладом множинного успадкування від метакласів АСОЦІАЦІЯ та КЛАС. Це означає, що асоціація-клас являється одночасно видом асоціації та видом класу. Обидві ці конструкції являються класифікаторами, а, отже, мають множину загальних властивостей, таких як можливість мати ім’я, характеристики і т.д. Оскільки ці властивості успадковуються від конструкції класифікатора, вони не повторюються. Тому асоціація-клас має тільки одне ім’я та множину характеристик, які визначені для класів та для асоціацій. Обмеження, визначені для класу та для асоціації, також застосовні для асоціації-класу, з чого випливає, наприклад, що атрибути асоціації класу, кінці асоціації класу та протилежні кінці асоціації, що з’єднані з асоціацією-класом, усі повинні мати різні імена. Більш того, правила спеціалізації й уточнення, визначенні для класу та асоціації, являються також застосовними для асоціації-класу.
<br><br>Асоціація-клас може бути використана для розширення властивостей N-арної асоціації.
</div>
<br><br><a href="#rel"><sub>[up]</sub></a>
<div id="agr">
<br><br><b><i>Агрегація</i></b><br><br>
<i>Агрегація(aggregation)</i> – напрямлене відношення між двома класами, що призначене для представлення ситуації, коли один з класів представляє собою деяку сутність, яка включає в себе в якості складових частин інші сутності.
<br><br>Агрегація має фундаментальне значення для опису структур складних систем, оскільки використовується для представлення системних взаємозв'язків типу „частина-ціле”. Розкриваючи внутрішню структуру системи, агрегація показує, з яких елементів складається система, та як вони зв’язані між собою. З точки зору моделі, окремі частини системи можуть виступати як в виді елементів, так і в виді підсистем, які, в свою чергу, також можуть складатися з підсистем чи елементів.
<br><br>Агрегація являється окремим випадком відношення асоціації, від якої вона успадковує такі властивості, як імена кінців асоціації, кратність та обмеження. Однак агрегаціями можуть бути тільки бінарні асоціації. При цьому семантика даного відношення по своїй суті описує декомпозицію чи розбиття складної системи на більш прості складові частини, які при необхідності також можуть бути декомпозовані.
<br><br>У зв’язку з розгляданням даного відношення можна згадати про спеціальний термін „агрегат”, який служить для позначення технічної системи, що складається з взаємодіючих складових частин чи підсистем. Ця аналогія не випадкова та може служити для більш наглядного розуміння сенсу відношення, яке розглядається.
<br><br>Розділення системи на складові частини, що розглядається в такому аспекті, також представляє собою деяку ієрархію, однак дана ієрархія принципово відрізняється від тої, яка породжується відношенням узагальнення. Різниця полягає в тому, що частини системи мають інший тип сутності, а значить не успадковують її властивості та поведінку, оскільки являються цілком самостійними сутностями. Більш того, частини цілого мають свої власні атрибути та операції, які відрізняються від атрибутів та операцій цілого.
<br><br>Графічно відношення агрегації зображується неперервною лінією, один з кінців якої представляє собою незамальований(пустий) всередині ромб в якості додаткового позначення термінала на агрегованому кінці лінії асоціації. Ромб агрегації по формі повинен бути меншим, ніж ромб в якості нотації асоціації. <u>Цей ромб вказує на той з класів, який представляє собою „клас-ціле” чи клас-контейнер. Інші класи являються його частинами.</u>
<br><br>Якщо існують дві чи більше агрегації для одного агрегату, вони можуть бути зображені в формі дерева. Будь які додаткові позначення для цього окремого сегмента використовуються до всіх кінців цієї агрегації.
 </div>
 <br><br><a href="#rel"><sub>[up]</sub></a>
 <div id="comp">
<br><br><b><i>Композиція</i></b><br><br>
<i>Композиція(composition)</i> чи <i>композитна агрегація </i>призначення для специфікації більш сильної форми відношення „частина-ціле” при якій із знищенням об’єкта класа-контейнера знищуються й усі об’єкти, що являються його складовими частинами.
<br><br>Відношення композиції являється окремим випадком відношення агрегації. При цьому вона являється сильною формою агрегації, яка потребує, щоб екземпляр-частина була включена в не більш ніж в один агрегат чи <i>композит</i>. Якщо композит видаляється, всі його частини зазвичай знищуються разом з ним. В мові UML 2.0 об’єкт-частина при необхідності може бути видалений з композита до того, як композит буде знищений.
<br><br>Графічно відношення композиції зображується неперервною лінією, один з кінців якої представляє собою замальований ромб („чорний ромб”). <u>Цей ромб вказує на той з класів, який представляє собою клас-композит. Інші класи являються його частинами.</u>
<br><br>Можливо, найбільш наглядний приклад цього відношення представляє собою жива клітина в біології, у відриві від якої не можуть існувати її складові частини. Інший приклад – вікно графічного інтерфейсу програми, яке може складатися з рядку заголовку, кнопок управління розміром, полос прокрутки, головного меню, робочої області та рядку- стану. Подібне вікно представляє собою клас, але його елементи також являються класами.
<br><br>Розробникам необхідно пам’ятати, що агрегація та композиція представляють собою транзитивні асиметричні відношення, звідки слідує обов’язкова вимога – їх зв’язки утворюють напрямлений ациклічний граф.
<br><br>В мові UML 2.0 порядок та спосіб, яким екземпляри частини створюються в композиті, не визначені.
</div>
<br><br><a href="#rel"><sub>[up]</sub></a>
<h3 id="dia">Діаграма варіантів використання (use-case diagram)</h3>
Вихідною моделлю, з якої починається процес моделювання в нотації UML, являється модель чи діаграма варіантів використання (діаграма прецедентів). Вона описує функціональне призначення системи в найбільш загальному вигляді з точки зору всіх її користувачів та зацікавлених осіб. Візуально діаграма варіантів використання є графом спеціального виду, який включає в себе спеціальні умовні зображення варіантів використання, акторів та відношень між ними. З формальної точки зору діаграма варіантів використання  є  спеціалізацією діаграми класів, для якої зображені класифікатори являються тільки акторами та варіантами використання. 
При розробці діаграми варіантів використання треба:
<ol>
<li>виділити акторів (будь-які об’єкти, суб’єкти чи системи, які взаємодіють з системою, що моделюється, ззовні).</li>
<li>визначити сервіси, котрі система представляє різним акторам.</li>
<li>визначити відношення між елементами діаграми:
<ul>
    <li>відношення <i>асоціації</i> завжди є бінарним та специфікує семантичні особливості окремої взаємодії актора та варіанта використання, позначається суцільною лінією, що з’єднує актора та варіант використання, та числами, що вказують кратність;</li>
    <li>відношення <i>включення (include)</i> специфікує той факт, що деякий варіант використання включає в себе поведінку, визначену в іншому варіанті використання. Семантично дане відношення означає, що поведінка чи виконання одного варіанта використання включається як складовий фрагмент в поведінці чи виконанні іншого варіанту використання. Графічно дане відношення позначається пунктирною лінією з “V”-образною стрілкою, що направлена від залежного варіанта використання до незалежного і позначається ключовим словом <<include>>;</li>
    <li>відношення <i>розширення (extend)</i> визначає взаємозв’язок одного варіанта використання з деяким іншим варіантом, функціональність чи поведінка якого задіяна першим не завжди, а тільки при виконанні певних умов. Графічно дане відношення зображається пунктирною лінією з “V”-образною стрілкою, направленою від залежного варіанта використання до незалежного і з’єднаною з ним точці розширення(extension point). Лінія зі стрілкою обов’язково помічається ключовим словом <<extend>>;</li>
    <li>відношення <i>узагальнення (generalization)</i>  призначено для специфікації того факту, що один елемент моделі являється спеціальним чи частковим випадком іншого елемента моделі. Відношення узагальнення може зв’язувати між собою тільки елементи одного типу. Графічно відношення узагальнення позначається суцільною лінією зі стрілкою в формі не замальованого трикутника, яка вказує на загальний елемент моделі.</li>
</ul></li>
</ol>
<center>
<table border="0" >
			<tr>
				<td><img border="0" src="../../source/ver1/teor1.jpg"></td>
			</tr>
            <tr>
				<td><center><i>Рис 3. Діаграма прецедентів</i></center></td>
			</tr>
</table>
</center>
<a href="#up"><sub>[up]</sub></a>
</div>
</body>
</html>