<html>
<head>
    <title>Об’єктно-орієнтоване програмування</title>
    <link rel="stylesheet" type="text/css" href="../../source/style.css">
</head>
<body background="../../source/background.jpg";>
<h1 align=center>Об’єктно-орієнтоване програмування</h1>
<table border="0" class="menu1" >
			<tr>
				<td><a href="../ver1/v1_1.html"><img border="0" src="../../source/v1.png"></a></td>
                <td><a href="../ver2/v2_1.html"><img border="0" src="../../source/v2.png"></a></td>
                <td><a href="../ver3/v3_1.html"><img border="0" src="../../source/v3.png"></a></td>
                <td><a href="../ver4/v4_1.html"><img border="0" src="../../source/v4.png"></a></td>
                <td><a href="../ver5/v5_1.html"><img border="0" src="../../source/v5.png"></a></td>
                <td><a href="../ver6/v6_1.html"><img border="0" src="../../source/v6.png"></a></td>
                <td><a href="../ver7/v7_1.html"><img border="0" src="../../source/v7.png"></a></td>
                <td><a href="../ver8/v8_1.html"><img border="0" src="../../source/v8.png"></a></td>
			</tr>
</table>
<table border="0" class="menu2">
			<tr>
				<td><a href="v6_1.html"><img border="0" src="../../source/m1.png"></a></td>
			</tr>
			<tr>
				<td><a href="v6_2.html"><img border="0" src="../../source/m2.png"></a></td>
			</tr>
            <tr>
				<td><a href="v6_3.html"><img border="0" src="../../source/m3.png"></a></td>
			</tr>
			<tr>
				<td><a href="v6_4.html"><img border="0" src="../../source/m4.png"></a></td>
			</tr>
            <tr>
				<td><a href="v6_5.html"><img border="0" src="../../source/m5.png"></a></td>
			</tr>
            <tr>
				<td><a href="v6_6.html"><img border="0" src="../../source/m6.png"></a></td>
			</tr>
            <tr>
				<td>&nbsp</td>
			</tr>
            <tr>
				<td>&nbsp</td>
			</tr>
            <tr>
				<td>&nbsp</td>
			</tr>
            <tr>
				<td><a href="../rating.html"><img border="0" src="../../source/m7.png"></a></td>
			</tr>
            <tr>
				<td><a href="../requir.html"><img border="0" src="../../source/m8.png"></a></td>
			</tr>
</table>
<a href="../../main.html"><img border="0" class="home" src="../../source/home.png"></a>
<div class="text">
<h2 id="up">Версія 6. Просте спадкування класів. Поліморфізм. Віртуальні функції. Діаграма класів, кооперацій.</h2>
<h3><u>Мета:</u></h3>
<ul>
    <li>вивчити особливості використання спадкування класів. Скласти програму, включивши класи що будуть успадковуватися від інших.</li>
</ul>

<h3><u>Теоретичні відомості</u></h3>
Використання поліморфізму та віртуальних функцій призводить до розробки простої програмної системи, яка легко розширюється. Програми включають менше логічних розгалужень та більше послідовного коду, що призводить до полегшення її налагодження, тестування та супроводження.
<br><br><b><i><u>Поліморфізм</u></i></b> – це здатність об’єктів класів, зв’язаних ієрархією спадкування, реагувати єдиним образом на однакові повідомлення. У спадковому ланцюжку методи класів мають однакові імена, але різні реалізації. Поліморфізм реалізується через механізм віртуальних функцій. 
<ul>
<li><a href="#inh">Спадкування</a></li>
<li><a href="#vir">Віртуальні функції</a></li>
</ul>

<h3 id="inh">Спадкування</h3>
<b><i><u>Спадкування</u></i></b> — це потужний механізм повторного використання коду. 
Спадкування дозволяє ієрархічно систематизувати родинні класи на підставі загальних властивостей. 
<ul>
<li>За допомогою спадкування може бути побудована ієрархія, що дозволяє використати той самий код й інтерфейс. </li>
<li>Нові класи утворюються за допомогою старих, позичаючи всі поля методів і реалізуючи деяку нову функціональність.</li>
<li>Класи, що знаходяться на вершині ієрархії, об’єднують в собі деяку кількість властивостей, спільних для всієї ієрархії.</li>
<li>Опускаючись по ієрархії донизу, здійснюється все більша деталізація.</li>
<li>Клас, що поєднує в собі властивості й методи, загальні для інших родинних класів, називається базовим класом. </li>
<li>Похідні класи успадковують властивості й функціональні особливості базового класу. </li>
</ul>
<h4>Переваги спадкування:</h4>
<ul>
<li>Дозволяє повторно використовувати створені раніше фрагменти програми і структури даних.</li>
<li>Дозволяє уникнути непотрібного дублювання коду.</li>
<li>Спрощує налагодження та супровід програм за рахунок додавання нових класів без зміни існуючих.</li>
<li>За допомогою ієрархії класів можна відтворити модель взаємовідносин реального світу.</li>
</ul>
<h4>Види спадкування</h4>
Вид спадкування описується специфікаторами доступу public, private, protected і дозволяє контролювати, які дані й методи базового класу входять у похідний клас:
<ul>
<li>
<i>відкрите </i>(public) спадкування означає, що відкриті, захищені й закриті члени базового класу є відповідно відкритими, захищеними й закритими членами в похідному класі;
<ul type="square">
<br><li>Відкрите спадкування відповідає співвідношенню «є», тобто клас Х є похідним класом від базового класу Y. Воно використовується, коли спадкування служить частиною інтерфейсу. </li>
</ul>
</li>
<br><li>
<i>захищене </i> (protected) спадкування означає, що всі відкриті члени базового класу стають захищеними в похідному класі;
<ul type="square">
<br><li>Захищене спадкування використовується, коли спадкування є   частиною інтерфейсу для похідного класу, але не є частиною інтерфейсу для користувача, тобто об'єкта (доступ закритий ззовні). </li>
</ul>
</li>
<br><li>
<i>закрите</i> (private) спадкування означає, що всі відкриті й захищені члени базового класу стають закритими в похідному класі, тобто вони недоступні похідному класу.
<ul type="square">
<br><li>Закрите спадкування використовується тоді, коли воно є особливістю реалізації й взагалі не є частиною інтерфейсу.</li>
</ul>
</li>
</ul>

<h4>Особливості успадкування:</h4>
<ol>
<li>Базовий клас описує загальні риси об’єктів. Усі класи, що походять від базового, успадковують можливості базового класу.</li>
<li>Похідні класи  доповнюють базові класи новими можливостями.</li>
<li>Об’єкт похідного класу можна присвоїти об’єкту базового класу, тому що похідний клас має елементи, відповідні кожному з членів базового класу.</li>
<li>Покажчик на об’єкт похідного класу можна  присвоїти  покажчику на об’єкт базового класу, тим самим здійснюється неявне приведення типів.</li>
<li>Покажчик на об’єкт базового класу можна перетворити на покажчик похідного класу, використовуючи явне приведення типів.</li>
</ol>

<h4>Конструктори та деструктори вихідних класів:</h4>
<ol>
<li>Конструктори не успадковуються, тому похідний клас повинен мати власні конструктори.</li>
<li>Конструктори не можуть бути статичними, тому що є обов’язковими членами класу.</li>
<li>Конструктори мають бути відкритими, тому що мають доступ до будь-якої частини класу, незалежно від специфікатора доступу.</li>
<li>Конструктори не можуть бути віртуальними, тому що не успадковуються.</li>
<li><b>Деструктори</b>, якщо вони визначені, викликаються у зворотній послідовності.</li>
<li>Якщо код <b>конструктора</b> виконаний, значить базовий клас і його члени вже ініціалізовані та їхнє використання припустиме.</li>
<li>Якщо виконано код <b>деструктора</b>, то базовий клас і всі об'єкти-члени ще не знищені, і їх можна використати.</li>
</ol>

<h4>Порядок виклику конструкторів:</h4>
<ol>
<li>Якщо в конструкторі похідного класу <b>явний виклик</b> конструктора базового класу відсутній, автоматично викликається конструктор базового класу за замовчуванням (тобто без параметрів).</li>
<li>Для ієрархії класів, що складається з декількох рівнів, конструктори базових класів викликаються, починаючи з найвищого рівня.</li>
<li>Після цього викликаються конструктори тих елементів класу, які є об’єктами, в порядку їх оголошення в класі, а потім виконується конструктор самого похідного класу.</li>
<li>Якщо конструктор базового класу потребує параметрів, він повинен бути явно викликаний в конструкторі похідного класу в списку ініціалізації.</li>
</ol>

<h4>Правила доступу для об’єктів і класів:</h4>
<ol>
<li>Елементи, які оголошені в класі як private, доступні функціям-членам цього класу та друзям класу.</li>
<li>Елементи, які оголошені як protected, доступні функціям-членам цього класу,  друзям класу та функціям-членам похідних класів.</li>
<li>Елементи, які оголошені як public, доступні будь-яким функціям-членам похідного класу.</li>
<li>Якщо клас використовується як відкритий базовий клас, то його відкриті члени стають відкритими членами похідних класів, захищені члени – захищеними членами похідних класів.</li>
<li>Якщо клас використовується як закритий базовий клас, то його відкриті та захищені члени стають закритими членами похідних класів.</li>
</ol>

<a href="#up"><sub>[up]</sub></a>

<h3 id="vir">Віртуальні функції</h3>
<b><u><i>Віртуальна функція</i></u></b> – це функція, яка оголошується в базовому класі та  перевизначається в похідних класах. Якщо при використання віртуальних функцій запит здійснюється за допомогою покажчика або посилання на базовий клас, то С++ вибирає перевизначену функцію у відповідному похідному класі, який зв’язаний з даним об’єктом. Завдяки використанню віртуальних функцій один і той самий виклик функції-елемента може привести до різних дій в залежності від типу об’єкта, який приймає цей виклик.
<br>Для розповсюдження поліморфної поведінки функції вниз по дереву ієрархії в кожному похідному класі треба оголосити одну й ту саму функцію віртуальною. Віртуальна функція, яка перевизначається у похідному класі, повинна мати ту саму сигнатуру та той самий тип значення, що повертається, що і віртуальна функція базового класу. У протилежному випадку фіксується синтаксична помилка. Віртуальна функція оголошується та визначається за допомогою специфікатора <b>virtual</b>. 
<br>Формат оголошення віртуальної функції:
<br><br><b>virtual тип_значення_що_повертається  ім’я_функції(параметри);</b>
<br><br>Формат визначення віртуальної функції:
<br><br><b>virtual тип_значення_що_повертається
<br>ім’я_класу::ім’я_функції(параметри)
<br>{   тіло функції  }
</b>
<h4>Правила використання віртуальних функцій:</h4>
<ul>
<li>віртуальні функції не можуть бути перевизначені в похідних класах з іншими типами значень, що повертаються;</li>
<li>переозначення віртуальних функцій з іншим переліком параметрів неможливо;</li>
<li>конструктор не може бути віртуальним;</li>
<li>віртуальний механізм можна виключити, використовуючи під час виклику функції ім’я класу з оператором :: розширення області дії.</li>
</ul>
Під час компіляції нема потреби знати тип об’єкта для компілювання виклику віртуальної функції. Під час виконання програми виклик віртуальної функції буде відповідати функції-елементу об’єкта, що викликається. Механізм визначення виклику віртуальної функції під час виконання програми називається <i>динамічним або пізнім зв’язуванням</i>. Для цього використовується таблиця віртуальних методів (<i>vtable</i>  або<i> vtbl</i>), яка містить масив покажчиків на реалізації віртуальних функцій у похідному класі. Для кожного класу з віртуальними функціями існує своя таблиця віртуальних методів. Кожний об’єкт класу з віртуальними функціями має покажчик на таблицю віртуальних методів цього класу, недоступний програмісту. Під час виконання програми поліморфні виклики віртуальних функцій здійснюються через розименування об’єкта, що дає доступ до<i> vtbl</i> класу. Далі в таблиці знаходиться відповідний покажчик на функцію, він розименується, що і завершує виклик віртуальної функції.

<br><br><a href="#up"><sub>[up]</sub></a>
</div>
</body>
</html>