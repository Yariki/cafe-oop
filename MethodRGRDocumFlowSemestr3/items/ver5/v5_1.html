<html>
<head>
    <title>Об’єктно-орієнтоване програмування</title>
    <link rel="stylesheet" type="text/css" href="../../source/style.css">
</head>
<body background="../../source/background.jpg";>
<h1 align=center>Об’єктно-орієнтоване програмування</h1>
<table border="0" class="menu1" >
			<tr>
				<td><a href="../ver1/v1_1.html"><img border="0" src="../../source/v1.png"></a></td>
                <td><a href="../ver2/v2_1.html"><img border="0" src="../../source/v2.png"></a></td>
                <td><a href="../ver3/v3_1.html"><img border="0" src="../../source/v3.png"></a></td>
                <td><a href="../ver4/v4_1.html"><img border="0" src="../../source/v4.png"></a></td>
                <td><a href="../ver5/v5_1.html"><img border="0" src="../../source/v5.png"></a></td>
                <td><a href="../ver6/v6_1.html"><img border="0" src="../../source/v6.png"></a></td>
                <td><a href="../ver7/v7_1.html"><img border="0" src="../../source/v7.png"></a></td>
                <td><a href="../ver8/v8_1.html"><img border="0" src="../../source/v8.png"></a></td>
			</tr>
</table>
<table border="0" class="menu2">
			<tr>
				<td><a href="v5_1.html"><img border="0" src="../../source/m1.png"></a></td>
			</tr>
			<tr>
				<td><a href="v5_2.html"><img border="0" src="../../source/m2.png"></a></td>
			</tr>
            <tr>
				<td><a href="v5_3.html"><img border="0" src="../../source/m3.png"></a></td>
			</tr>
			<tr>
				<td><a href="v5_4.html"><img border="0" src="../../source/m4.png"></a></td>
			</tr>
            <tr>
				<td><a href="v5_5.html"><img border="0" src="../../source/m5.png"></a></td>
			</tr>
            <tr>
				<td><a href="v5_6.html"><img border="0" src="../../source/m6.png"></a></td>
			</tr>
            <tr>
				<td>&nbsp</td>
			</tr>
            <tr>
				<td>&nbsp</td>
			</tr>
            <tr>
				<td>&nbsp</td>
			</tr>
            <tr>
				<td><a href="../rating.html"><img border="0" src="../../source/m7.png"></a></td>
			</tr>
            <tr>
				<td><a href="../requir.html"><img border="0" src="../../source/m8.png"></a></td>
			</tr>
</table>
<a href="../../main.html"><img border="0" class="home" src="../../source/home.png"></a>
<div class="text">
<h2 id="up">Версія 5. Перевантаження операцій та функцій. Дружні функції. Діаграми класів, станів і переходів.</h2>
<h3><u>Мета:</u></h3>
<ul>
    <li>вивчити особливості використання операторних функцій. Скласти програму, включивши до інтерфейсу класу операторні функції для переозначення арифметичних операцій, перетворення типів, виведення та введення об’єктів.</li>
</ul>

<h3><u>Теоретичні відомості</u></h3>

<ul>
<li><a href="#fr">Поняття дружніх функцій</a></li>
<li><a href="#over">Поняття перевантаження операцій</a></li>
</ul>

<h3 id="fr">Поняття дружніх функцій</h3>
Безпосередній доступ до елементів даних класу мають функції-елементи цього класу. 
<br>Але, якщо функція чи клас оголошені як дружні певному класу, то вони мають безпосередній доступ до всіх елементів того класу, для якого вони дружні.
<br>Дружні функції та класи мають доступ до закритих елементів класу без використання функцій-елементів цього класу.
<br><br><b>Використання дружніх функцій необхідно у випадках:</b>
<ol>
<li>Коли одна і та сама функція повинна бути елементом двох класів, що неможливо для простої функції-елементу. 
<br><br><b>Рішення.</b> В цьому випадку функцію оголошують дружньою в обох класах, а визначають в одному з них.</li>
<br><br><li>Коли бажано мати неявне перетворення типів всіх операндів якої-небудь операції. 
<br><br><b>Рішення. </b>Функцію, що реалізує ці перетворення, визначають як дружню цьому класу.</li>
<br><br><li>Коли потрібно мати доступ до закритої частини будь-якого класу.
<br><br><b>Рішення. </b>В класі оголошують дружню функцію, яка має доступ до закритих елементів даних та функцій-елементів.</li>
</ol>
<b>Особливості:</b>
<ul>
<li>Дружні функції не належать класу, але в них оголошуються.</li>
<li>Дружні функції визначаються поза інтерфейсом класу без посилання на клас і використання оператора розширення області видимості.</li>
</ul>
<b>Правила застосування дружніх функцій:</b>
<ol>
<li>Дружня функція повинна бути оголошена як friend в тому класі, для якого вона дружня.</li>
<li>Специфікатори доступу public, private, protected не впливають на рівень доступу friend-функції до елементів даних дружнього класу.</li>
<li>Дружня функція повинна використовувати явний параметр.</li>
<li>Для дружньої функції не існує покажчик this як неявний перший її параметр.</li>
<li>Специфікатори  friend не взаємні, тобто якщо функція f(), оголошена в класі Х, є дружньою класу Y, то це не означає, що клас Y дружній функції f().</li>
<li>Дружність не успадковується : якщо клас Х оголошує клас Y дружнім, то класи, похідні від Y, не будуть автоматично одержувати доступ до елементів класу Х.</li>
<li>Дружність не є перехідною властивістю: якщо клас Х оголошує клас Y дружнім, то похідні від Х класи не будуть визнавати дружність класу Y.</li>
<li>Можуть бути дружніми класи.</li>
</ol>
<b>Оголошення дружніх класів:</b>
<br><br>class X
 	<br>		{
   	<br>		     friend class Y;
		<br>	.........
		<br>	 };<br><br>
<a href="#up"><sub>[up]</sub></a>
<h3 id="over">Поняття перевантаження операцій</h3>
<ul>
<li>Над об'єктами класу не можна виконувати ті самі операції арифметичного, логічного та іншого змісту, що і над скалярними змінними.</li>
<li>С++ дозволяє застосовувати стандартні операції до об’єктів класів за умови точного опису їх дій.</li>
</ul>
Визначення способу виконання операцій з об’єктами конкретного класу називається <b><i><u>перевантаженням операцій</u></i></b>.
<ul>
<li>Спосіб виконання перевантажених операцій визначає користувач. </li>
<li>Перевантажені операції, застосовані для об'єктів класів, поводять себе подібно вбудованим і дозволяють класам користувача не відрізнятися синтаксично від вбудованих типів.</li>
</ul>
<h4>Перевантажені операції:</h4>
<i>//присвоєння копіюванням</i>
<br>T& operator =(const T&);
<br><br><i>//бінарні арифметичні операції</i>
<br>T operator ω( const T&) const;
<br><br><i>// бінарні арифметичні, сполучені з присвоєнням</i>
<br>T& operator ω=(const T&);
<br><br><i>//приведення типу T до типу S</i>
<br>operator S();
<br><br><i>//інфіксного інкременту (звичайний спосіб)</i>
<br>T operator ++();	
<br><br><i>//постфіксного інкременту (фіктивний параметр)</i>
<br>T operator ++(int);
<br><br><i>//обчислення адреси</i>
<br>T* operator &() const;	
<br><br><i>//кон’юнкція</i>
<br>T operator &( const T&);
<br><br><i>//доступ за покажчиком</i>
<br>T* operator->(); 
<br><br><i>//індексація об’єктів</i>
<br>T& operator[](int i);
<br><br><i>//введення та виведення класів потоків</i>
<br>istream& operator>>(…); 
<br><br><i>//виклик функції</i>
<br>тип operator(); 
<br><br>Можливе перевантаження інших операцій.
<br><br><b>Обмеження на перевантаження операцій:</b>
<ol>
<li>Не дозволяється перевантажувати такі операції:<ul>
    <br><li>доступ до елементів структури, класу (.);</li>
    <li>розіменування покажчика (*);</li>
    <li>оператор області видимості (::);</li>
    <li>умовний вираз a>b ? a : b  (?).</li>
</ul></li>
<br><li>Старшинство (пріоритет) операцій не може змінитися.</li>
<br><li>З перевантаженими операціями не можна використовувати аргументи по замовчанню.</li>
<br><li>Не можна змінити кількість операндів, які обробляються перевантаженою операцією.</li>
<br><li>Не можна змінити роботу операцій з об’єктами вбудованих типів.</li>
<br><li>Створювати нові операції неможливо. Перевантажуються тільки стандартні операції.</li>
</ol>
<b>Особливості операторних функцій:</b>
<ol>
<br><li>Кількість параметрів співпадає з кількістю операндів (явно чи не явно оголошеними) перевантаженої операції.</li>
<br><li>Операторна функція повинна бути або членом класу, або приймати об’єкти в якості аргументів.</li>
<br><li>Якщо перевантаження здійснює член класу, то лівий операнд має бути об’єктом класу, а правий – параметром.</li>
<br><li>Перевантажувати операторну функцію можна багатократно.</li>
<br><li>Операторні функції можуть бути унарні і бінарні.</li>
</ol>
С++ дозволяє означити функції з однаковим іменем, але з різною сигнатурою параметрів. 
<br>Компілятор знаходить потрібну функцію по відповідності типів  аргументів. 
<br><br><b>Обмеження на використання перевантажених функцій:</b>
<ol>
<br><li>Не можуть перевантажуватися функції, що відрізняються тільки типом значення, що повертається. Компілятор враховує тільки різницю у типах аргументів.</li>
<br><li>Не можуть бути перевантажені функції, параметри яких відрізняються кваліфікатором const або використанням посилань.</li>
</ol>
<b>Рекомендації щодо правил перевантаження:</b>
<ol>
<br><li>Перевантаження унарних операцій – список параметрів порожній.</li>
<br><li>Для постфіксного інкремента і декремента (++, --) у списку параметрів включений один параметр типу int.</li>
<br><li>Перевантаження бінарних операцій – список параметрів складається з одного параметру – об’єкту, що є другим операндом.</li>
<br><li>Бінарні операції (+,-,*,/) повертають в якості результату новий об’єкт.</li>
<br><li>Бінарні операції, сумісні із присвоєнням (+=, -=, *=, …), повертають в якості результату свій перший операнд.</li>
<br><li>Операція індексування має один параметр (індекс елемента) і повертає посилання на елемент, до якого звертається.</li>
<br><li>Якщо повертається посилання на елемент, то будуть працювати як конструкції виду a = v[i], так і конструкції виду v[i] = a.</li>
<br><li>У випадку використання в тексті програми операції присвоювання для двох змінних об’єктного типу компілятор здійснює <b>просте копіювання полів</b>.</li>
<br><li><b>Конструктор копіювання</b> викликається, якщо відбувається створення нового об’єкта. Якщо виконується присвоювання у вже існуючий об’єкт, то викликається <b>операція присвоювання</b>.</li>
<br><li>При виконанні <b>операції присвоювання</b> в об’єкті, в який здійснюється присвоєння,  вже є дані. Тому, на відміну від конструктора копіювання, в першу чергу необхідно звільнити зайняту пам’ять.</li>
<br><li>Якщо клас має <b>поля-покажчики</b>, присвоєння, яке здійснюється компілятором, призводить до втрати пам’яті, появи “близнюків” і, серйозним збоям в роботі програми.</li>
<br><li>Якщо в класі є поля-покажчики, необхідно перевантажувати операцію присвоювання.</li>
</ol>
<a href="#up"><sub>[up]</sub></a>
</div>
</body>
</html>